{"version":3,"file":"main.b6d5ad219f5b40c5832c.bundle.js","sources":["webpack:///../core/src/base-axis-chart.ts"],"sourcesContent":["// D3 Imports\nimport { select } from \"d3-selection\";\nimport { scaleBand, scaleLinear, ScaleBand, ScaleLinear } from \"d3-scale\";\nimport { axisBottom, axisLeft, axisRight } from \"d3-axis\";\nimport { min, max } from \"d3-array\";\n\nimport { BaseChart } from \"./base-chart\";\n\nimport * as Configuration from \"./configuration\";\nimport { ChartConfig, AxisChartOptions } from \"./configuration\";\nimport { Tools } from \"./tools\";\n\nexport class BaseAxisChart extends BaseChart {\n\tx: ScaleBand<any>;\n\ty: ScaleLinear<any, any>;\n\ty2: ScaleLinear<any, any>;\n\tthresholdDimensions: any;\n\n\toptions: any = Tools.merge({}, Configuration.options.AXIS);\n\n\tconstructor(holder: Element, configs: ChartConfig<AxisChartOptions>) {\n\t\tsuper(holder, configs);\n\n\t\tif (configs.options) {\n\t\t\tthis.options = Tools.merge({}, this.options, configs.options);\n\t\t\tconst { axis } = configs.options;\n\t\t\tif (axis) {\n\t\t\t\tthis.x = axis.x;\n\t\t\t\tthis.y = axis.y;\n\t\t\t\tthis.y2 = axis.y2;\n\t\t\t}\n\t\t}\n\t}\n\n\tsetSVG(): any {\n\t\tsuper.setSVG();\n\n\t\tthis.container.classed(\"chart-axis\", true);\n\t\tthis.innerWrap.append(\"g\")\n\t\t\t.attr(\"class\", \"x grid\");\n\t\tthis.innerWrap.append(\"g\")\n\t\t\t.attr(\"class\", \"y grid\");\n\n\t\treturn this.svg;\n\t}\n\n\tinitialDraw(data?: any) {\n\t\tif (data) {\n\t\t\tthis.displayData = data;\n\t\t}\n\n\t\t// If an axis exists\n\t\tconst xAxisRef = select(this.holder).select(\".axis.x\");\n\t\tif (!xAxisRef.node()) {\n\t\t\tthis.setSVG();\n\n\t\t\t// Scale out the domains\n\t\t\t// Set the x & y axis as well as their labels\n\t\t\tthis.setXScale();\n\t\t\tthis.setXAxis();\n\t\t\tthis.setYScale();\n\t\t\tthis.setYAxis();\n\n\t\t\t// Draws the grid\n\t\t\tthis.drawGrid();\n\n\t\t\tthis.addOrUpdateLegend();\n\t\t} else {\n\t\t\tconst holderRef = select(this.holder);\n\n\t\t\tthis.innerWrap = holderRef.select(\"g.inner-wrap\");\n\t\t\tthis.svg = holderRef.select(\"svg.chart-svg\");\n\t\t}\n\n\t\tthis.draw();\n\n\t\tthis.addDataPointEventListener();\n\t}\n\n\tupdate() {\n\t\tthis.displayData = this.updateDisplayData();\n\n\t\tthis.updateXandYGrid();\n\t\tthis.setXScale();\n\t\tthis.setXAxis();\n\t\tthis.setYScale();\n\t\tthis.setYAxis();\n\t\tthis.drawBackdrop();\n\t\tthis.interpolateValues(this.displayData);\n\t}\n\n\tupdateDisplayData() {\n\t\tconst oldData = Tools.clone(this.data);\n\t\tconst activeLegendItems = this.getActiveLegendItems();\n\n\t\t// Get new data by filtering the data based off of the legend\n\t\tconst newDisplayData = Object.assign({}, oldData);\n\t\tif (this.getLegendType() === Configuration.legend.basedOn.SERIES) {\n\t\t\tnewDisplayData.datasets = oldData.datasets.filter(dataset => {\n\t\t\t\t// If this datapoint is active on the legend\n\t\t\t\tconst activeSeriesItemIndex = activeLegendItems.indexOf(dataset.label);\n\n\t\t\t\treturn activeSeriesItemIndex !== -1;\n\t\t\t});\n\t\t} else {\n\t\t\tconst dataIndeciesToRemove = [];\n\t\t\tnewDisplayData.labels = oldData.labels.filter((label, index) => {\n\t\t\t\t// If this datapoint is active on the legend\n\t\t\t\tconst activeSeriesItemIndex = activeLegendItems.indexOf(label);\n\n\t\t\t\tif (activeSeriesItemIndex === -1) {\n\t\t\t\t\tdataIndeciesToRemove.push(index);\n\t\t\t\t}\n\n\t\t\t\treturn activeSeriesItemIndex !== -1;\n\t\t\t});\n\n\t\t\tif (dataIndeciesToRemove.length > 0) {\n\t\t\t\tnewDisplayData.datasets = oldData.datasets.map(dataset => {\n\t\t\t\t\tdataset.data = dataset.data.filter((dataPoint, i) => {\n\t\t\t\t\t\treturn dataIndeciesToRemove.indexOf(i) === -1;\n\t\t\t\t\t});\n\n\t\t\t\t\treturn dataset;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn newDisplayData;\n\t}\n\n\taddLabelsToDataPoints(d, index) {\n\t\tconst { datasets } = this.displayData;\n\n\t\treturn datasets.map(dataset => ({\n\t\t\tlabel: d,\n\t\t\tdatasetLabel: dataset.label,\n\t\t\tvalue: dataset.data[index]\n\t\t}));\n\t}\n\n\tdraw() {\n\t\tconsole.warn(\"You should implement your own `draw()` function.\");\n\t}\n\n\tinterpolateValues(newData: any) {\n\t\tconsole.warn(\"You should implement your own `interpolateValues()` function.\");\n\t}\n\n\t/**************************************\n\t *  Computations/Calculations         *\n\t *************************************/\n\t// TODO - Refactor\n\tgetChartSize(container = this.container) {\n\t\tlet ratio, marginForLegendTop, marginForChartTitle;\n\t\tif (container.node().clientWidth > Configuration.charts.widthBreak) {\n\t\t\tratio = Configuration.charts.magicRatio;\n\t\t\tmarginForLegendTop = 0;\n\t\t} else {\n\t\t\tmarginForLegendTop = Configuration.charts.marginForLegendTop;\n\t\t\tratio = 1;\n\t\t}\n\n\t\t// Store computed actual size, to be considered for change if chart does not support axis\n\t\tconst marginsToExclude = Configuration.charts.margin.left + Configuration.charts.margin.right;\n\n\t\tmarginForChartTitle = this.options.title ? Configuration.charts.title.marginBottom : 0;\n\n\t\tconst computedChartSize = {\n\t\t\theight: container.node().clientHeight - marginForLegendTop - marginForChartTitle,\n\t\t\twidth: (container.node().clientWidth - marginsToExclude) * ratio\n\t\t};\n\n\t\treturn {\n\t\t\theight: Math.max(computedChartSize.height, Configuration.charts.axisCharts.minHeight),\n\t\t\twidth: Math.max(computedChartSize.width, Configuration.charts.axisCharts.minWidth)\n\t\t};\n\t}\n\n\tresizeChart() {\n\t\t// Reposition the legend\n\t\tthis.positionLegend();\n\n\t\tif (this.innerWrap.select(\".axis-label.x\").nodes().length > 0 || this.options.scales.x.title) {\n\t\t\tthis.repositionXAxisTitle();\n\t\t}\n\n\t\tif (this.innerWrap.select(\".axis-label.y\").nodes().length > 0 || this.options.scales.y.title) {\n\t\t\tthis.repositionYAxisTitle();\n\t\t}\n\n\t\tthis.dispatchEvent(\"resize\");\n\t\tthis.drawBackdrop();\n\t}\n\n\t/**************************************\n\t *  Axis & Grids                      *\n\t *************************************/\n\n\tsetXScale(xScale?: any) {\n\t\tif (xScale) {\n\t\t\tthis.x = xScale;\n\t\t} else {\n\t\t\tconst { bar: margins } = Configuration.charts.margin;\n\t\t\tconst { scales } = this.options;\n\n\t\t\tconst chartSize = this.getChartSize();\n\t\t\tconst width = chartSize.width - margins.left - margins.right;\n\n\t\t\tthis.x = scaleBand().rangeRound([0, width]).padding(Configuration.scales.x.padding);\n\t\t\tthis.x.domain(this.displayData.labels);\n\t\t}\n\t}\n\n\tsetXAxis(noAnimation?: boolean) {\n\t\tconst { bar: margins } = Configuration.charts.margin;\n\t\tconst chartSize = this.getChartSize();\n\t\tconst height = chartSize.height - margins.top - margins.bottom;\n\n\t\tconst t = noAnimation ? this.getInstantTransition() : this.getDefaultTransition();\n\n\t\tconst xAxis = axisBottom(this.x)\n\t\t\t.tickSize(0)\n\t\t\t.tickSizeOuter(0);\n\t\tlet xAxisRef = this.svg.select(\"g.x.axis\");\n\n\t\t// If the <g class=\"x axis\"> exists in the chart SVG, just update it\n\t\tif (xAxisRef.nodes().length > 0) {\n\t\t\txAxisRef = this.svg.select(\"g.x.axis\")\n\t\t\t\t.transition(t)\n\t\t\t\t.attr(\"transform\", `translate(0, ${height})`)\n\t\t\t\t// Casting to any because d3 does not offer appropriate typings for the .call() function\n\t\t\t\t.call(xAxis);\n\t\t} else {\n\t\t\txAxisRef = this.innerWrap.append(\"g\")\n\t\t\t\t.attr(\"class\", \"x axis\");\n\n\t\t\txAxisRef.call(xAxis);\n\t\t}\n\n\t\t// Update the position of the pieces of text inside x-axis\n\t\txAxisRef.selectAll(\"g.tick text\")\n\t\t\t.attr(\"y\", Configuration.scales.magicY1)\n\t\t\t.attr(\"x\", Configuration.scales.magicX1)\n\t\t\t.attr(\"dy\", \".35em\")\n\t\t\t.attr(\"transform\", `rotate(${Configuration.scales.xAxisAngle})`)\n\t\t\t.style(\"text-anchor\", \"end\")\n\t\t\t.call(text => this.wrapTick(text));\n\n\t\t// get the tickHeight after the ticks have been wrapped\n\t\tconst tickHeight = this.getLargestTickHeight(xAxisRef.selectAll(\".tick\")) + Configuration.scales.tick.heightAddition;\n\t\t// Add x-axis title\n\t\tif (this.innerWrap.select(\".axis-label.x\").nodes().length === 0 && this.options.scales.x.title) {\n\t\t\txAxisRef.append(\"text\")\n\t\t\t\t.attr(\"class\", \"x axis-label\")\n\t\t\t\t.attr(\"text-anchor\", \"middle\")\n\t\t\t\t.attr(\"transform\", `translate(${xAxisRef.node().getBBox().width / 2}, ${tickHeight})`)\n\t\t\t\t.text(this.options.scales.x.title);\n\t\t}\n\n\t\t// get the yHeight after the height of the axis has settled\n\t\tconst yHeight = this.getChartSize().height - this.svg.select(\".x.axis\").node().getBBox().height;\n\t\txAxisRef.attr(\"transform\", `translate(0, ${yHeight})`);\n\t}\n\n\trepositionXAxisTitle() {\n\t\tconst xAxisRef = this.svg.select(\"g.x.axis\");\n\t\tconst tickHeight = this.getLargestTickHeight(xAxisRef.selectAll(\".tick\")) + Configuration.scales.tick.heightAddition;\n\n\t\tconst xAxisTitleRef = this.svg.select(\"g.x.axis text.x.axis-label\");\n\t\txAxisTitleRef.attr(\"class\", \"x axis-label\")\n\t\t\t.attr(\"text-anchor\", \"middle\")\n\t\t\t.attr(\"transform\", `translate(${xAxisRef.node().getBBox().width / 2}, ${tickHeight})`)\n\t\t\t.text(this.options.scales.x.title);\n\t}\n\n\trepositionYAxisTitle() {\n\t\tconst yAxisRef = this.svg.select(\"g.y.axis\");\n\t\tconst tickHeight = this.getLargestTickHeight(yAxisRef.selectAll(\".tick\"));\n\n\t\tconst yAxisTitleRef = this.svg.select(\"g.y.axis text.y.axis-label\");\n\n\t\tconst yAxisCenter = yAxisRef.node().getBBox().height / 2;\n\t\tconst yAxisLabelWidth = this.innerWrap.select(\".axis-label.y\").node().getBBox().width;\n\n\t\tconst yAxisTitleTranslate = {\n\t\t\tx: - yAxisCenter + yAxisLabelWidth / 2,\n\t\t\ty: - (tickHeight + Configuration.scales.tick.heightAddition)\n\t\t};\n\n\t\t// Align y axis title with y axis\n\t\tyAxisTitleRef.attr(\"class\", \"y axis-label\")\n\t\t.attr(\"text-align\", \"center\")\n\t\t.attr(\"transform\", `rotate(-90) translate(${yAxisTitleTranslate.x}, ${yAxisTitleTranslate.y})`)\n\t\t.text(this.options.scales.y.title);\n\t}\n\n\tgetYMax() {\n\t\tconst { datasets } = this.displayData;\n\t\tconst { scales } = this.options;\n\t\tlet yMax;\n\n\t\tif (datasets.length === 1) {\n\t\t\tyMax = max(datasets[0].data);\n\t\t} else {\n\t\t\tyMax = max(datasets, (d: any) => (max(d.data)));\n\t\t}\n\n\t\tif (scales.y.yMaxAdjuster) {\n\t\t\tyMax = scales.y.yMaxAdjuster(yMax);\n\t\t}\n\n\t\treturn yMax;\n\t}\n\n\tgetYMin() {\n\t\tconst { datasets } = this.displayData;\n\t\tconst { scales } = this.options;\n\t\tlet yMin;\n\n\t\tif (datasets.length === 1) {\n\t\t\tyMin = min(datasets[0].data);\n\t\t} else {\n\t\t\tyMin = min(datasets, (d: any) => (min(d.data)));\n\t\t}\n\n\t\tif (scales.y.yMinAdjuster) {\n\t\t\tyMin = scales.y.yMinAdjuster(yMin);\n\t\t}\n\n\t\treturn yMin;\n\t}\n\n\tsetYScale(yScale?: any) {\n\t\tconst chartSize = this.getChartSize();\n\t\tconst height = chartSize.height - this.innerWrap.select(\".x.axis\").node().getBBox().height;\n\n\t\tconst { scales } = this.options;\n\n\t\tconst yMin = this.getYMin();\n\t\tconst yMax = this.getYMax();\n\t\tif (yScale) {\n\t\t\tthis.y = yScale;\n\t\t} else {\n\t\t\tthis.y = scaleLinear().range([height, 0]);\n\t\t\tthis.y.domain([Math.min(yMin, 0), yMax]);\n\t\t}\n\n\t\tif (scales.y2 && scales.y2.ticks.max) {\n\t\t\tthis.y2 = scaleLinear().rangeRound([height, 0]);\n\t\t\tthis.y2.domain([scales.y2.ticks.min, scales.y2.ticks.max]);\n\t\t}\n\t}\n\n\tsetYAxis(noAnimation?: boolean) {\n\t\tconst chartSize = this.getChartSize();\n\n\t\tconst { scales } = this.options;\n\t\tconst t = noAnimation ? this.getInstantTransition() : this.getDefaultTransition();\n\n\t\tconst yAxis = axisLeft(this.y)\n\t\t\t.ticks(scales.y.numberOfTicks || Configuration.scales.y.numberOfTicks)\n\t\t\t.tickSize(0)\n\t\t\t.tickFormat(scales.y.formatter);\n\n\t\tlet yAxisRef = this.svg.select(\"g.y.axis\");\n\t\tconst horizontalLine = this.svg.select(\"line.domain\");\n\n\t\tthis.svg.select(\"g.x.axis path.domain\")\n\t\t\t.remove();\n\n\t\t// If the <g class=\"y axis\"> exists in the chart SVG, just update it\n\t\tif (yAxisRef.nodes().length > 0) {\n\t\t\tyAxisRef.transition(t)\n\t\t\t\t// Casting to any because d3 does not offer appropriate typings for the .call() function\n\t\t\t\t.call(yAxis as any);\n\n\t\t\thorizontalLine.transition(t)\n\t\t\t\t.attr(\"y1\", this.y(0))\n\t\t\t\t.attr(\"y2\", this.y(0))\n\t\t\t\t.attr(\"x1\", 0)\n\t\t\t\t.attr(\"x2\", chartSize.width);\n\t\t} else {\n\t\t\tyAxisRef = this.innerWrap.append(\"g\")\n\t\t\t\t.attr(\"class\", \"y axis yAxes\");\n\n\t\t\tyAxisRef.call(yAxis);\n\n\t\t\tyAxisRef.append(\"line\")\n\t\t\t\t.classed(\"domain\", true)\n\t\t\t\t.attr(\"y1\", this.y(0))\n\t\t\t\t.attr(\"y2\", this.y(0))\n\t\t\t\t.attr(\"x1\", 0)\n\t\t\t\t.attr(\"x2\", chartSize.width);\n\t\t}\n\n\t\tconst tickHeight = this.getLargestTickHeight(yAxisRef.selectAll(\".tick\"));\n\n\t\t// Add y-axis title\n\t\tif (this.innerWrap.select(\".axis-label.y\").nodes().length === 0 && this.options.scales.y.title) {\n\t\t\tyAxisRef.append(\"text\")\n\t\t\t\t.attr(\"class\", \"y axis-label\")\n\t\t\t\t.text(this.options.scales.y.title);\n\n\t\t\tconst yAxisCenter = yAxisRef.node().getBBox().height / 2;\n\t\t\tconst yAxisLabelWidth = this.innerWrap.select(\".axis-label.y\").node().getBBox().width;\n\n\t\t\tconst yAxisTitleTranslate = {\n\t\t\t\tx: - yAxisCenter + yAxisLabelWidth / 2,\n\t\t\t\ty: - (tickHeight + Configuration.scales.tick.heightAddition)\n\t\t\t};\n\n\t\t\t// Align y axis title on the y axis\n\t\t\tthis.innerWrap.select(\".axis-label.y\")\n\t\t\t\t.attr(\"transform\", `rotate(-90) translate(${yAxisTitleTranslate.x}, ${yAxisTitleTranslate.y})`);\n\t\t}\n\n\t\tTools.moveToFront(horizontalLine);\n\n\t\tif (scales.y2 && scales.y2.ticks.max) {\n\t\t\tconst secondaryYAxis = axisRight(this.y2)\n\t\t\t\t.ticks(scales.y2.numberOfTicks || Configuration.scales.y2.numberOfTicks)\n\t\t\t\t.tickSize(0)\n\t\t\t\t.tickFormat(scales.y2.formatter);\n\n\t\t\tconst secondaryYAxisRef = this.svg.select(\"g.y2.axis\");\n\t\t\t// If the <g class=\"y axis\"> exists in the chart SVG, just update it\n\t\t\tif (secondaryYAxisRef.nodes().length > 0) {\n\t\t\t\tsecondaryYAxisRef.transition(t)\n\t\t\t\t\t.attr(\"transform\", `translate(${this.getChartSize().width}, 0)`)\n\t\t\t\t\t// Being cast to any because d3 does not offer appropriate typings for the .call() function\n\t\t\t\t\t.call(secondaryYAxis as any);\n\t\t\t} else {\n\t\t\t\tthis.innerWrap.append(\"g\")\n\t\t\t\t\t.attr(\"class\", \"y2 axis yAxes\")\n\t\t\t\t\t.attr(\"transform\", `translate(${this.getChartSize().width}, 0)`)\n\t\t\t\t\t.call(secondaryYAxis);\n\t\t\t}\n\t\t}\n\t}\n\n\tdrawGrid() {\n\t\t// Draw the x & y grid\n\t\tthis.drawXGrid();\n\t\tthis.drawYGrid();\n\n\t\t// Draw the backdrop\n\t\tthis.drawBackdrop();\n\t}\n\n\tdrawXGrid() {\n\t\tconst yHeight = this.getChartSize().height - this.getBBox(\".x.axis\").height;\n\t\tconst xGrid = axisBottom(this.x)\n\t\t\t.tickSizeInner(-yHeight)\n\t\t\t.tickSizeOuter(0);\n\n\t\tconst g = this.innerWrap.select(\".x.grid\")\n\t\t\t.attr(\"transform\", `translate(0, ${yHeight})`)\n\t\t\t.call(xGrid);\n\n\t\tthis.cleanGrid(g);\n\t}\n\n\tdrawYGrid() {\n\t\tconst { scales } = this.options;\n\t\tconst { thresholds } = this.options.scales.y;\n\t\tconst yHeight = this.getChartSize().height - this.getBBox(\".x.axis\").height;\n\n\t\tconst yGrid = axisLeft(this.y)\n\t\t\t.tickSizeInner(-this.getChartSize().width)\n\t\t\t.tickSizeOuter(0);\n\n\t\tyGrid.ticks(scales.y.numberOfTicks || Configuration.scales.y.numberOfTicks);\n\n\t\tconst g = this.innerWrap.select(\".y.grid\")\n\t\t\t.attr(\"transform\", \"translate(0, 0)\")\n\t\t\t.call(yGrid);\n\n\t\tthis.cleanGrid(g);\n\n\t\tif (thresholds && thresholds.length > 0) {\n\t\t\tthis.addOrUpdateThresholds(g, false);\n\t\t}\n\t}\n\n\t/**\n\t * Draws the background for the chart grid. Uses the axis to get the bounds and position of the backdrop.\n\t */\n\tdrawBackdrop() {\n\t\tconst backdrop = Tools.appendOrSelect(this.innerWrap, \"rect.chart-grid-backdrop\");\n\t\tconst [xScaleStart, xScaleEnd] = this.x.range();\n\t\tconst [yScaleEnd, yScaleStart] = this.y.range();\n\n\t\tbackdrop\n\t\t\t.attr(\"x\", xScaleStart)\n\t\t\t.attr(\"y\", yScaleStart)\n\t\t\t.attr(\"width\", xScaleEnd)\n\t\t\t.attr(\"height\", yScaleEnd)\n\t\t\t.lower();\n\t}\n\n\taddOrUpdateThresholds(yGrid, animate?) {\n\t\tconst t = animate === false ? this.getInstantTransition() : this.getDefaultTransition();\n\n\t\tconst width = this.getChartSize().width;\n\t\tconst { thresholds } = this.options.scales.y;\n\n\t\t// Check if the thresholds container <g> exists\n\t\tconst thresholdContainerExists = this.innerWrap.select(\"g.thresholds\").nodes().length > 0;\n\t\tconst thresholdRects = thresholdContainerExists\n\t\t\t? this.innerWrap.selectAll(\"g.thresholds rect\")\n\t\t\t: this.innerWrap.append(\"g\").classed(\"thresholds\", true).selectAll(\"rect\").data(thresholds);\n\n\t\tconst calculateYPosition = d => {\n\t\t\treturn Math.max(0, this.y(d.range[1]));\n\t\t};\n\n\t\tconst calculateHeight = d => {\n\t\t\tconst height = Math.abs(this.y(d.range[1]) - this.y(d.range[0]));\n\t\t\tconst yMax = this.y(this.y.domain()[0]);\n\n\t\t\t// If the threshold is getting cropped because it is extending beyond\n\t\t\t// the top of the chart, update its height to reflect the crop\n\t\t\tif (this.y(d.range[1]) < 0) {\n\t\t\t\treturn Math.max(0, height + this.y(d.range[1]));\n\t\t\t} else if (this.y(d.range[1]) + height > yMax) {\n\t\t\t\t// If the threshold is getting cropped because it is extending beyond\n\t\t\t\t// the bottom of the chart, update its height to reflect the crop\n\t\t\t\treturn Math.max(0, yMax - calculateYPosition(d));\n\t\t\t}\n\n\t\t\treturn Math.max(0, height);\n\t\t};\n\n\t\tconst calculateOpacity = d => {\n\t\t\tconst height = Math.abs(this.y(d.range[1]) - this.y(d.range[0]));\n\n\t\t\t// If the threshold is to be shown anywhere\n\t\t\t// outside of the top edge of the chart, hide it\n\t\t\tif (this.y(d.range[1]) + height <= 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\treturn 1;\n\t\t};\n\n\t\t// Applies to thresholds being added\n\t\tthresholdRects.enter()\n\t\t\t.append(\"rect\")\n\t\t\t.classed(\"threshold-bar\", true)\n\t\t\t.attr(\"x\", 0)\n\t\t\t.attr(\"y\", d => calculateYPosition(d))\n\t\t\t.attr(\"width\", width)\n\t\t\t.attr(\"height\", d => calculateHeight(d))\n\t\t\t.attr(\"fill\", d => Configuration.scales.y.thresholds.colors[d.theme])\n\t\t\t.style(\"opacity\", 0)\n\t\t\t.transition(t)\n\t\t\t.style(\"opacity\", d => calculateOpacity(d));\n\n\t\t// Update thresholds\n\t\tthresholdRects\n\t\t\t.transition(t)\n\t\t\t.attr(\"x\", 0)\n\t\t\t.attr(\"y\", d => calculateYPosition(d))\n\t\t\t.attr(\"width\", width)\n\t\t\t.attr(\"height\", d => calculateHeight(d))\n\t\t\t.style(\"opacity\", d => calculateOpacity(d))\n\t\t\t.attr(\"fill\", d => Configuration.scales.y.thresholds.colors[d.theme]);\n\n\t\t// Applies to thresholds getting removed\n\t\tthresholdRects.exit()\n\t\t\t.transition(t)\n\t\t\t.style(\"opacity\", 0)\n\t\t\t.remove();\n\t}\n\n\tupdateXandYGrid(noAnimation?: boolean) {\n\t\tconst { thresholds } = this.options.scales.y;\n\n\t\t// setTimeout is needed here, to take into account the new position of bars\n\t\t// Right after transitions are initiated for the\n\t\tsetTimeout(() => {\n\t\t\tconst t = noAnimation ? this.getInstantTransition() : this.getDefaultTransition();\n\n\t\t\t// Update X Grid\n\t\t\tconst chartSize = this.getChartSize();\n\t\t\tconst yHeight = chartSize.height - this.getBBox(\".x.axis\").height;\n\t\t\tconst xGrid = axisBottom(this.x)\n\t\t\t\t.tickSizeInner(-yHeight)\n\t\t\t\t.tickSizeOuter(0);\n\n\t\t\tconst g_xGrid = this.innerWrap.select(\".x.grid\")\n\t\t\t\t.transition(t)\n\t\t\t\t.attr(\"transform\", `translate(0, ${yHeight})`)\n\t\t\t\t.call(xGrid);\n\n\t\t\tthis.cleanGrid(g_xGrid);\n\n\t\t\t// Update Y Grid\n\t\t\tconst yGrid = axisLeft(this.y)\n\t\t\t\t.tickSizeInner(-chartSize.width)\n\t\t\t\t.tickSizeOuter(0)\n\t\t\t\t.tickFormat(\"\" as any);\n\n\t\t\tconst g_yGrid = this.innerWrap.select(\".y.grid\")\n\t\t\t\t.transition(t)\n\t\t\t\t.attr(\"transform\", `translate(0, 0)`)\n\t\t\t\t.call(yGrid);\n\n\t\t\tg_yGrid.transition(t);\n\n\t\t\tthis.cleanGrid(g_yGrid);\n\n\t\t\tif (thresholds && thresholds.length > 0) {\n\t\t\t\tthis.addOrUpdateThresholds(g_yGrid, !noAnimation);\n\t\t\t}\n\t\t}, 0);\n\t}\n\n\tcleanGrid(g) {\n\t\tg.selectAll(\"line\")\n\t\t\t.attr(\"stroke\", Configuration.grid.strokeColor);\n\t\tg.selectAll(\"text\").style(\"display\", \"none\").remove();\n\t\tg.select(\".domain\").style(\"stroke\", \"none\");\n\t}\n\n\t// TODO - Refactor\n\twrapTick(ticks) {\n\t\tconst self = this;\n\t\tconst lineHeight = Configuration.scales.tick.lineHeight;\n\n\t\tticks.each(function (t) {\n\t\t\tconst text = select(this);\n\t\t\tlet textContent = text.text();\n\n\t\t\t// If the text has already been broken down into parts\n\t\t\tif (text.selectAll(\"tspan\").nodes().length > 1) {\n\t\t\t\ttextContent = text.selectAll(\"tspan\")\n\t\t\t\t\t.nodes()\n\t\t\t\t\t.map(node => select(node).text())\n\t\t\t\t\t.join(\" \");\n\t\t\t}\n\n\t\t\tconst words = textContent.split(/\\s+/).reverse();\n\t\t\tconst y = text.attr(\"y\");\n\t\t\tconst dy = parseFloat(text.attr(\"dy\"));\n\n\t\t\tlet word;\n\t\t\tlet line = [];\n\t\t\tlet lineNumber = 0;\n\t\t\tlet tspan = text.text(null)\n\t\t\t\t.append(\"tspan\")\n\t\t\t\t.attr(\"x\", 0);\n\n\t\t\t// Set max length allowed to length of datapoints\n\t\t\t// In the x-scale\n\t\t\tconst maxTextLengthAllowed = self.x.bandwidth();\n\t\t\twhile (word = words.pop()) {\n\t\t\t\tline.push(word);\n\t\t\t\ttspan.text(line.join(\" \"));\n\n\t\t\t\t// Get text length and compare to maximum length allowed\n\t\t\t\tconst tspanTextLength = tspan.node().getComputedTextLength();\n\t\t\t\tif (tspanTextLength > maxTextLengthAllowed) {\n\t\t\t\t\tline.pop();\n\t\t\t\t\ttspan.text(line.join(\" \"));\n\t\t\t\t\tline = [word];\n\n\t\t\t\t\ttspan = text.append(\"tspan\")\n\t\t\t\t\t\t.attr(\"x\", 0)\n\t\t\t\t\t\t.attr(\"y\", y)\n\t\t\t\t\t\t.attr(\"dy\", ++lineNumber * lineHeight + dy + \"em\")\n\t\t\t\t\t\t.text(word);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t// TODO - Refactor\n\tgetLargestTickHeight(ticks) {\n\t\tlet largestHeight = 0;\n\t\tticks.each(function() {\n\t\t\tlet tickLength = 0;\n\t\t\ttry {\n\t\t\t\ttickLength = this.getBBox().height;\n\t\t\t} catch (e) {\n\t\t\t\tconsole.log(e);\n\t\t\t}\n\t\t\tif (tickLength > largestHeight) {\n\t\t\t\tlargestHeight = tickLength;\n\t\t\t}\n\n\t\t});\n\t\treturn largestHeight;\n\t}\n\n\t/**************************************\n\t *  Events & User interactions        *\n\t *************************************/\n\taddDataPointEventListener() {\n\t\tconsole.warn(\"You should implement your own `addDataPointEventListener()` function.\");\n\t}\n}\n"],"mappings":"AACA","sourceRoot":""}